{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}\n"
    },
    "contracts/access/Authorization.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;"
    },
    "contracts/ChainPilotEntryPoint.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;"
    },
    "contracts/core/AutomationAgent.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\n/**\n* @author @0xJonaseb11\n * @title ChainPilot - Automation Agent\n * @notice Orchestrates tasks, handles gas, and integrates offchain agents/AI.\n * @dev Acts as a middleware between users and core contracts (Scheduler/Executer).\n */\n\n\n////////////////////////////////////////////////////\n/////  I THINK THIS CONTRACT IS NOT MUCH USEFUL ///\n/////  SINCE Executor and Scheduler are already ////\n///////////////////////////////////////////////////\n\ncontract AutomationAgent {\n    // ------------------------ Custom Errors ------------------------\n    error Unauthorized();\n    error InsufficientGasCredit();\n    error TaskConditionsNotMet();\n\n    // ------------------------ Structs & Events ------------------------\n    struct TaskConfig {\n        address user;\n        address target;\n        bytes payload;\n        uint256 gasCredit;  \n        bytes32 conditionsHash;  \n    }\n\n    event TaskSubscribed(uint256 indexed taskId, address indexed user);\n    event TaskAutoExecuted(uint256 indexed taskId, bool success);\n\n    // ------------------------ Immutables ------------------------\n    address public immutable scheduler;\n    address public immutable executer;\n\n    // ------------------------ Storage ------------------------\n    mapping(uint256 => TaskConfig) public tasks;\n    uint256 public taskIdCounter;\n\n    // ------------------------ Constructor ------------------------\n    constructor(address _scheduler, address _executer) {\n        scheduler = _scheduler;\n        executer = _executer;\n    }\n\n    // ------------------------ Core Functions ------------------------\n    /**\n     * @notice Subscribe to a new automated task (called by users).\n     * @param target Contract to interact with (e.g., Executer.sol).\n     * @param payload Encoded function call.\n     * @param gasCredit ETH reserved for gas (use 0 for self-funded).\n     * @param conditionsHash Offchain-checked conditions (e.g., \"APY > 5%\").\n     */\n    function subscribeTask(\n        address target,\n        bytes calldata payload,\n        uint256 gasCredit,\n        bytes32 conditionsHash\n    ) external payable returns (uint256 taskId) {\n        taskId = taskIdCounter++;\n        tasks[taskId] = TaskConfig(\n            msg.sender,\n            target,\n            payload,\n            gasCredit,\n            conditionsHash\n        );\n\n        if (gasCredit > 0) {\n            // User prepays gas (optional)\n            if (msg.value < gasCredit) revert InsufficientGasCredit();\n        }\n\n        emit TaskSubscribed(taskId, msg.sender);\n    }\n\n    /**\n     * @notice Execute a task if conditions are met (called by offchain AI/keeper).\n     * @dev Offchain agents validate conditionsHash before calling.\n     */\n    function executeTask(\n        uint256 taskId,\n        bytes calldata conditionsProof  // E.g., signed APY data\n    ) external {\n        TaskConfig memory config = tasks[taskId];\n        if (config.user == address(0)) revert Unauthorized();\n\n        if (!_validateConditions(config.conditionsHash, conditionsProof)) {\n            revert TaskConditionsNotMet();\n        }\n\n        // Use prepaid gas or user's wallet\n        uint256 gasToUse = config.gasCredit > 0 ? config.gasCredit : 0;\n\n        (bool success, ) = executer.call{value: gasToUse}(\n            abi.encodeWithSignature(\n                \"executeTask(address,address,bytes,uint256)\",\n                config.user,\n                config.target,\n                config.payload,\n                0  // value\n            )\n        );\n\n        emit TaskAutoExecuted(taskId, success);\n    }\n\n    // ------------------------ Internal ------------------------\n    function _validateConditions(\n        bytes32 conditionsHash,\n        bytes calldata proof\n    ) internal pure returns (bool) {\n        // like.. Verify signed offchain data (forex.., APY > 5%)\n        /////////////////////////////////////////////////////////////////////////////////\n        //// ask Sipho if which oracle we'll have to use btn chainlink n gelato | flare//\n        /////////////////////////////////////////////////////////////////////////////////\n        return conditionsHash == keccak256(proof);\n    }\n}"
    },
    "contracts/core/Executor.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\n/**\n * @author @0xJonaseb11\n * @title ChainPilotExecutor Contract\n * @notice Securely executes pre-approved tasks from Scheduler\n * @dev Uses EIP-712 signatures for approvals and optimized for Base network\n */\n\n///////////////////////////////////////////////////\n////////   REMEMBER TO ASK SIPHO IF WE NEED AA ////\n////////.  SO I CAN SETUP EntryPoint.sol ////////\n////////////////////////////////////////////////\n\ncontract ChainPilotExecutor {\n\n    // ------------------------ Custom Errors ------------------------\n    error UnauthorizedExecuter(address user, bytes32 taskHash);\n    error ExecutionFailed(bytes reason);\n    error InvalidValue(uint256 expected, uint256 actual);\n    error ExpiredApproval(uint256 deadline);\n\n    // ------------------------ Events ------------------------\n    event TaskApproved(\n        address indexed user,\n        bytes32 indexed taskHash,\n        uint256 maxValue,\n        uint256 deadline\n    );\n    event TaskExecuted(\n        address indexed user,\n        address indexed target,\n        bytes32 indexed taskHash,\n        uint256 value,\n        bool success\n    );\n\n    // ------------------------ Storage ------------------------\n    struct Approval {\n        uint256 maxValue;\n        uint256 deadline;\n    }\n\n    mapping(address => mapping(bytes32 => Approval)) public userApprovals;\n\n    // ------------------------ External Functions ------------------------\n    /**\n     * @notice Pre-approve a task with deadline\n     */\n    function approveTask(\n        address target,\n        bytes calldata payload,\n        uint256 maxValue,\n        uint256 deadline\n    ) external {\n        bytes32 taskHash = getTaskHash(target, payload, maxValue);\n        userApprovals[msg.sender][taskHash] = Approval(maxValue, deadline);\n        emit TaskApproved(msg.sender, taskHash, maxValue, deadline);\n    }\n\n    /**\n     * @notice Execute a pre-approved task from Scheduler\n     */\n    function executeTask(\n        address user,\n        address target,\n        bytes32 payloadHash,\n        uint256 value\n    ) external payable returns (bool) {\n        Approval memory approval = userApprovals[user][payloadHash];\n        \n        if (approval.deadline == 0) revert UnauthorizedExecuter(user, payloadHash);\n        if (block.timestamp > approval.deadline) revert ExpiredApproval(approval.deadline);\n        if (value > approval.maxValue) revert InvalidValue(approval.maxValue, value);\n        if (msg.value != value) revert InvalidValue(value, msg.value);\n\n        (bool success, bytes memory reason) = target.call{value: value}(\n            abi.encodePacked(payloadHash, user)\n        );\n\n        if (!success) revert ExecutionFailed(reason);\n\n        emit TaskExecuted(user, target, payloadHash, value, success);\n        return success;\n    }\n\n    // ------------------------ Public Functions ------------------------\n    /**\n     * @notice Compute task hash for approval\n     */\n    function getTaskHash(\n        address target,\n        bytes calldata payload,\n        uint256 maxValue\n    ) public pure returns (bytes32) {\n        return keccak256(abi.encode(target, keccak256(payload), maxValue));\n    }\n}"
    },
    "contracts/core/Scheduler.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\n/** \n * @author @0xJonaseb11\n * @title ChainPilotScheduler Contract\n * @notice Queues time-based tasks for off-chain keepers to execute via Executer.\n * @dev Features tight integration with Executer contract, packed storage, and enhanced security.\n */\n\nimport { ChainPilotExecutor } from \"./Executor.sol\";\n\ncontract ChainPilotScheduler is ChainPilotExecutor {\n\n    // ------------------------ Custom Errors ------------------------\n    error Unauthorized(address caller, address owner);\n    error InvalidTask(string reason);\n    error TaskNotFound(uint256 taskId);\n    error TaskAlreadyCancelled(uint256 taskId);\n    error InvalidTimeWindow(uint256 from, uint256 to);\n    error ExecutionWindowNotReached(uint256 executeAt, uint256 currentTime);\n    error ExecutionWindowExpired(uint256 executeAt, uint256 expiry);\n\n    // ------------------------ Events ------------------------\n    event TaskScheduled(\n        uint256 indexed taskId,\n        address indexed user,\n        address indexed executer,\n        address target,\n        uint64 executeAt,\n        uint64 expiryAt,\n        bytes32 payloadHash,\n        uint256 value\n    );\n    event TaskCancelled(uint256 indexed taskId);\n    event TaskExecuted(uint256 indexed taskId, address indexed executor);\n\n    // ------------------------ Structs ------------------------\n    struct Task {\n        uint64 executeAt;       \n        uint64 expiryAt;        \n        address user;          \n        address executer;      \n        address target;         \n        bytes32 payloadHash;    \n        uint256 value;         \n        bool isCancelled;      \n    }\n\n    // ------------------------ Storage ------------------------\n    mapping(uint256 => Task) public tasks;\n    uint256 public taskIdCounter;\n    address public immutable executerAddress;\n\n    // ------------------------ Constructor ------------------------\n    constructor(address _executer) {\n        executerAddress = _executer;\n    }\n\n    // ------------------------ Modifiers ------------------------\n    modifier onlyTaskOwner(uint256 taskId) {\n        if (tasks[taskId].user != msg.sender) {\n            revert Unauthorized(msg.sender, tasks[taskId].user);\n        }\n        _;\n    }\n\n    modifier validTask(uint256 taskId) {\n        if (taskId >= taskIdCounter) revert TaskNotFound(taskId);\n        _;\n    }\n\n    // ------------------------ Externals ------------------------\n    /**\n     * @notice Schedule a new task via Executer\n     * @param executeAt When the task should run (timestamp)\n     * @param expiryAt When the task becomes invalid (0 for no expiry)\n     * @param target The final target contract\n     * @param payload Encoded function call data\n     * @param value ETH/value to be sent with the call\n     */\n    function scheduleTask(\n        uint64 executeAt,\n        uint64 expiryAt,\n        address target,\n        bytes calldata payload,\n        uint256 value\n    ) external returns (uint256 taskId) {\n        if (executeAt < block.timestamp + 60) {\n            revert InvalidTask(\"Execution time must be at least 1 minute in future\");\n        }\n        if (expiryAt != 0 && expiryAt <= executeAt) {\n            revert InvalidTask(\"Expiry must be after execution time\");\n        }\n        if (target == address(0)) {\n            revert InvalidTask(\"Target cannot be zero address\");\n        }\n\n        taskId = taskIdCounter++;\n        bytes32 payloadHash = keccak256(payload);\n        \n        tasks[taskId] = Task({\n            executeAt: executeAt,\n            expiryAt: expiryAt,\n            user: msg.sender,\n            executer: executerAddress,\n            target: target,\n            payloadHash: payloadHash,\n            value: value,\n            isCancelled: false\n        });\n\n        emit TaskScheduled(\n            taskId,\n            msg.sender,\n            executerAddress,\n            target,\n            executeAt,\n            expiryAt,\n            payloadHash,\n            value\n        );\n    }\n\n    /**\n     * @notice Cancel a scheduled task\n     */\n    function cancelTask(uint256 taskId) \n        external \n        validTask(taskId)\n        onlyTaskOwner(taskId)\n    {\n        Task storage task = tasks[taskId];\n        \n        if (task.isCancelled) revert TaskAlreadyCancelled(taskId);\n        if (block.timestamp >= task.executeAt) {\n            revert ExecutionWindowNotReached(task.executeAt, block.timestamp);\n        }\n\n        task.isCancelled = true;\n        emit TaskCancelled(taskId);\n    }\n\n    // ------------------------ Keepers ------------------------\n    /**\n     * @notice Execute a scheduled task via Executer\n     */\n    function executeTask(uint256 taskId) \n        external \n        validTask(taskId)\n        returns (bool)\n    {\n        Task memory task = tasks[taskId];\n\n        if (task.isCancelled) revert TaskAlreadyCancelled(taskId);\n        if (block.timestamp < task.executeAt) {\n            revert ExecutionWindowNotReached(task.executeAt, block.timestamp);\n        }\n        if (task.expiryAt != 0 && block.timestamp > task.expiryAt) {\n            revert ExecutionWindowExpired(task.executeAt, task.expiryAt);\n        }\n\n        // prevent re-execution\n        tasks[taskId].isCancelled = true;\n\n        // Forward to Executer contract\n        bool success = ChainPilotExecutor(task.executer).executeTask{value: task.value}(\n            task.user,\n            task.target,\n            task.payloadHash,\n            task.value\n        );\n\n        emit TaskExecuted(taskId, msg.sender);\n        return success;\n    }\n\n    // ------------------------ Views ------------------------\n    /**\n     * @notice Get pending tasks within a time range\n     */\n    function getPendingTasks(uint256 from, uint256 to) \n        external \n        view \n        returns (uint256[] memory) \n    {\n        if (from > to) revert InvalidTimeWindow(from, to);\n        \n        uint256[] memory pendingTasks = new uint256[](taskIdCounter);\n        uint256 count = 0;\n\n        for (uint256 i = 0; i < taskIdCounter; i++) {\n            Task memory task = tasks[i];\n            if (!task.isCancelled && \n                task.executeAt >= from && \n                task.executeAt <= to &&\n                (task.expiryAt == 0 || block.timestamp <= task.expiryAt)) {\n                pendingTasks[count++] = i;\n            }\n        }\n\n        assembly { mstore(pendingTasks, count) }\n        return pendingTasks;\n    }\n}"
    },
    "contracts/core/TemplateManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\n/**\n * @author @0xJonaseb11\n * @title ChainPilot - Template Manager\n * @notice Stores reusable task templates (e.g., multi-send, DAO voting scripts).\n * @dev Templates are gas-optimized for batch operations and can be cloned by users.\n */\ncontract TemplateManager {\n    // ------------------------ Custom Errors ------------------------\n    error Unauthorized();\n    error InvalidTemplate();\n    error TemplateLocked();\n    error ExecutionFailed();\n\n    // ------------------------ Structs & Events ------------------------\n    struct Template {\n        address owner;\n        address target;\n        bytes payload;  \n        bool isPublic;\n        bool isLocked;  \n    }\n    event TemplateCreated(uint256 indexed templateId, address indexed owner);\n    event TemplateUsed(uint256 indexed templateId, address indexed user);\n\n    // ------------------------ Storage ------------------------\n    mapping(uint256 => Template) public templates;\n    uint256 public templateIdCounter;\n\n    // ------------------------ External Functions ------------------------\n    /**\n     * @notice Create a new template.\n     * @param target Contract to interact with (e.g., Executer.sol).\n     * @param payload Encoded batch operation (use ABI.encodePacked for arrays).\n     * @param isPublic If true, anyone can use this template.\n     */\n    function createTemplate(\n        address target,\n        bytes calldata payload,\n        bool isPublic\n    ) external returns (uint256 templateId) {\n        if (target == address(0) || payload.length == 0) revert InvalidTemplate();\n\n        templateId = templateIdCounter++;\n        templates[templateId] = Template(msg.sender, target, payload, isPublic, false);\n\n        emit TemplateCreated(templateId, msg.sender);\n    }\n\n    /**\n     * @notice Lock a template (makes it immutable).\n     * @dev Only the owner can lock.\n     */\n    function lockTemplate(uint256 templateId) external {\n        Template storage template = templates[templateId];\n        if (template.owner != msg.sender) revert Unauthorized();\n        template.isLocked = true;\n    }\n\n    // ------------------------ Template Execution ------------------------\n    /**\n     * @notice Use a template to execute a batch task.\n     * @dev Calls the pre-defined payload via Executer.sol.\n     */\n    function useTemplate(uint256 templateId) external {\n        Template memory template = templates[templateId];\n        if (!template.isPublic && template.owner != msg.sender) revert Unauthorized();\n\n        (bool success, ) = template.target.call(template.payload);\n        if (!success) revert ExecutionFailed();\n\n        emit TemplateUsed(templateId, msg.sender);\n    }\n}\n"
    },
    "contracts/interfaces/IAutomationAgent.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\ninterface IAutomationAgent {\n    function executeTask(uint256 taskId) external;\n}\n"
    },
    "contracts/interfaces/IExecutor.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\ninterface IExecutor {\n    function executeTask(uint256 taskId) external;\n}"
    },
    "contracts/interfaces/IScheduler.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\ninterface IScheduler {\n    function scheduleTask(uint256 executeAt, address target, bytes calldata payload) external;\n    function cancelTask(uint256 taskId) external;\n}\n"
    },
    "contracts/interfaces/ITemplateManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\ninterface ITemplateManager {\n    function deployTemplate() external;\n}\n"
    },
    "contracts/modules/base/Base.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\n/**\n * @title ChainPilot - Base Contract\n * @notice Provides core utilities for all modules: ownership, pausing, and reentrancy protection.\n * @dev Inherited by all module contracts (Payments, Staking, etc.). Designed for Base L2 deployment.\n */\nabstract contract Base {\n    // ------------------------ Custom Errors ------------------------\n    error Unauthorized();\n    error ContractPaused();\n    error InvalidAddress();\n\n    // ------------------------ Storage ------------------------\n    address public owner;\n    bool public paused;\n\n    // ------------------------ Events ------------------------\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n    event Paused(address indexed account);\n    event Unpaused(address indexed account);\n\n    // ------------------------ Modifiers ------------------------\n    modifier onlyOwner() {\n        if (msg.sender != owner) revert Unauthorized();\n        _;\n    }\n\n    modifier whenNotPaused() {\n        if (paused) revert ContractPaused();\n        _;\n    }\n\n    // ------------------------ Constructor ------------------------\n    constructor(address _owner) {\n        if (_owner == address(0)) revert InvalidAddress();\n        owner = _owner;\n    }\n\n    // ------------------------ Ownership Management ------------------------\n    /**\n     * @notice Transfer contract ownership.\n     * @param newOwner Address of the new owner.\n     */\n    function transferOwnership(address newOwner) external onlyOwner {\n        if (newOwner == address(0)) revert InvalidAddress();\n        emit OwnershipTransferred(owner, newOwner);\n        owner = newOwner;\n    }\n\n    // ------------------------ Pause Control ------------------------\n    /**\n     * @notice Pause all critical functionality (emergency use).\n     */\n    function pause() external onlyOwner {\n        paused = true;\n        emit Paused(msg.sender);\n    }\n\n    /**\n     * @notice Unpause the contract.\n     */\n    function unpause() external onlyOwner {\n        paused = false;\n        emit Unpaused(msg.sender);\n    }\n}"
    },
    "contracts/modules/payments/PaymentsModule.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport {Base} from \"../base/Base.sol\";\n\n/**\n * @author @0xJonaseb11\n * @title ChainPilot - Payments Module\n * @notice Handles single and batch ETH/ERC20 transfers with gas optimizations.\n * @dev Inherits from Base.sol for shared utilities (e.g., error handling, access control).\n */\ncontract PaymentsModule is Base {\n    // ------------------------ Custom Errors ------------------------\n    error InvalidPaymentAmount();\n    error TransferFailed();\n    error UnauthorizedBatch();\n\n    // ------------------------ Events ------------------------\n    event SinglePaymentSent(\n        address indexed sender,\n        address indexed recipient,\n        uint256 amount\n    );\n    event BatchPaymentSent(\n        address indexed sender,\n        uint256 totalAmount,\n        uint256 recipientCount\n    );\n\n    // ------------------------ Constructor ------------------------\n    constructor(address _owner) Base(_owner) {}\n\n    // ------------------------ External Functions ------------------------\n\n    /**\n     * @notice Send ETH to a single recipient.\n     * @param recipient Address to receive ETH.\n     * @param amount Amount in wei.\n     */\n    function sendETH(\n        address recipient,\n        uint256 amount\n    ) external payable {\n        if (amount == 0 || msg.value != amount) revert InvalidPaymentAmount();\n        \n        (bool success, ) = recipient.call{value: amount}(\"\");\n        if (!success) revert TransferFailed();\n\n        emit SinglePaymentSent(msg.sender, recipient, amount);\n    }\n\n    /**\n     * @notice Batch send ETH to multiple recipients.\n     * @param recipients Array of addresses to receive ETH.\n     * @param amounts Array of amounts in wei (parallel array to recipients).\n     * @dev Uses assembly for gas-efficient loops.\n     */\n    function batchSendETH(\n        address[] calldata recipients,\n        uint256[] calldata amounts\n    ) external payable {\n        if (recipients.length != amounts.length) revert InvalidPaymentAmount();\n\n        uint256 totalAmount;\n        unchecked {\n            for (uint256 i = 0; i < recipients.length; i++) {\n                totalAmount += amounts[i];\n            }\n        }\n        if (msg.value != totalAmount) revert InvalidPaymentAmount();\n\n        // Gas-efficient loop with assembly\n        bool allSuccess = true;\n        assembly {\n            let len := recipients.length\n            let i := 0\n            for { } lt(i, len) { } {\n                let recipient := calldataload(add(recipients.offset, mul(i, 0x20)))\n                let amount := calldataload(add(amounts.offset, mul(i, 0x20)))\n                \n                let success := call(gas(), recipient, amount, 0, 0, 0, 0)\n                if iszero(success) {\n                    allSuccess := false\n                    break\n                }\n                i := add(i, 1)\n            }\n        }\n        if (!allSuccess) revert TransferFailed();\n\n        emit BatchPaymentSent(msg.sender, totalAmount, recipients.length);\n    }\n\n    // ------------------------ ERC20 Support ------------------------\n    /**\n     * @notice Batch send ERC20 tokens (requires prior approval).\n     * @param token ERC20 token contract address.\n     * @param recipients Array of recipient addresses.\n     * @param amounts Array of token amounts.\n     */\n    function batchSendERC20(\n        address token,\n        address[] calldata recipients,\n        uint256[] calldata amounts\n    ) external {\n        if (recipients.length != amounts.length) revert InvalidPaymentAmount();\n\n        bool allSuccess = true;\n        for (uint256 i = 0; i < recipients.length; ) {\n            (bool success, ) = token.call(\n                abi.encodeWithSelector(\n                    0xa9059cbb, // transfer(address,uint256)\n                    recipients[i],\n                    amounts[i]\n                )\n            );\n            if (!success) {\n                allSuccess = false;\n                break;\n            }\n            unchecked { i++; }\n        }\n        if (!allSuccess) revert TransferFailed();\n    }\n}"
    },
    "contracts/modules/staking/StakingModule.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {Base} from \"../base/Base.sol\";\n\n/**\n * @author @0xJonaseb11\n * @title ChainPilot - Staking Module\n * @notice Handles ERC20/ETH staking with time/amount-based rewards.\n * @dev Inherits from Base.sol for ownership/pausing. Uses checkpointing for scalable rewards.\n */\ncontract StakingModule is Base {\n    // ------------------------ Structs & Events ------------------------\n    struct Stake {\n        uint256 amount;\n        uint256 startTime;\n        uint256 lastClaimTime;\n    }\n\n    struct RewardConfig {\n        uint256 rate; \n        uint256 minStakeDuration;\n        address rewardToken;\n    }\n\n    event Staked(address indexed user, uint256 amount);\n    event Unstaked(address indexed user, uint256 amount);\n    event RewardClaimed(address indexed user, uint256 amount);\n\n    error InvalidAmount();\n    error NoStake();\n\n    // ------------------------ Storage ------------------------\n    IERC20 public immutable stakingToken;\n    RewardConfig public rewardConfig;\n\n    mapping(address => Stake) public stakes;\n    uint256 public totalStaked;\n\n    // ------------------------ Constructor ------------------------\n    constructor(\n        address _owner,\n        address _stakingToken,\n        uint256 _rewardRate,\n        uint256 _minStakeDuration,\n        address _rewardToken\n    ) Base(_owner) {\n        stakingToken = IERC20(_stakingToken);\n        rewardConfig = RewardConfig(\n            _rewardRate,\n            _minStakeDuration,\n            _rewardToken\n        );\n    }\n\n    // ------------------------ External Functions ------------------------\n    /**\n     * @notice Stake tokens to earn rewards.\n     * @param amount Amount of tokens to stake (must approve first).\n     */\n    function stake(uint256 amount) external whenNotPaused {\n        if (amount == 0) revert InvalidAmount();\n\n        Stake storage userStake = stakes[msg.sender];\n        _claimRewards(msg.sender); \n\n        userStake.amount += amount;\n        userStake.startTime = block.timestamp;\n        userStake.lastClaimTime = block.timestamp;\n\n        totalStaked += amount;\n        stakingToken.transferFrom(msg.sender, address(this), amount);\n\n        emit Staked(msg.sender, amount);\n    }\n\n    /**\n     * @notice Unstake tokens (forfeits unclaimed rewards if early).\n     */\n    function unstake() external {\n        Stake memory userStake = stakes[msg.sender];\n        if (userStake.amount == 0) revert NoStake();\n\n        uint256 amount = userStake.amount;\n        totalStaked -= amount;\n\n        // Penalize early unstakes\n        if (block.timestamp < userStake.startTime + rewardConfig.minStakeDuration) {\n            amount = (amount * 80) / 100; // 20% penalty\n        } else {\n            _claimRewards(msg.sender);\n        }\n\n        delete stakes[msg.sender];\n        stakingToken.transfer(msg.sender, amount);\n\n        emit Unstaked(msg.sender, amount);\n    }\n\n    /**\n     * @notice Claim pending rewards without unstaking.\n     */\n    function claimRewards() external {\n        _claimRewards(msg.sender);\n    }\n\n    // ------------------------ Views ------------------------\n    /**\n     * @notice Calculate pending rewards for a user.\n     * @dev Uses checkpointing to avoid storage writes during reads.\n     */\n    function pendingRewards(address user) public view returns (uint256) {\n        Stake memory userStake = stakes[user];\n        if (userStake.amount == 0) return 0;\n\n        uint256 elapsed = block.timestamp - userStake.lastClaimTime;\n        return (userStake.amount * rewardConfig.rate * elapsed) / 1e18;\n    }\n\n    // ------------------------ Admins ------------------------\n    /**\n     * @notice Update reward rate (owner only).\n     */\n    function setRewardRate(uint256 newRate) external onlyOwner {\n        rewardConfig.rate = newRate;\n    }\n\n    // ------------------------ Internals------------------------\n    function _claimRewards(address user) internal {\n        uint256 rewards = pendingRewards(user);\n        if (rewards == 0) return;\n\n        stakes[user].lastClaimTime = block.timestamp;\n        IERC20(rewardConfig.rewardToken).transfer(user, rewards);\n\n        emit RewardClaimed(user, rewards);\n    }\n}"
    },
    "contracts/modules/voting/VotingModules.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\n// Still thinking about it if it is that needed!"
    },
    "contracts/utils/DAOUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;"
    },
    "contracts/utils/TimeUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;"
    },
    "contracts/utils/TokenUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}